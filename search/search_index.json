{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BOMBE Docs","text":"<p>Welcome to BOMBE Docs!</p> <p>BOMBE (Battle Of Malware Bypass and EDR) is a match where malware and EDR systems compete against each other inside a single VM. It's like a Attack and Defense style of CTF, but different! We will provide quick start guide and some direction for those who are new to this field.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"Learn/EDR/API-Hooking/","title":"API Hooking","text":""},{"location":"Learn/EDR/ETW/","title":"ETW","text":"<p>Event Tracing for Windows (ETW) provides a mechanism to trace and log events that are raised by user-mode applications and kernel-mode drivers.</p> <p></p> <p>The components of ETW include Controller, Provider, Consumer, and Session :</p> <ul> <li>Controller: Controls the enabling/disabling of Providers, creates Sessions, and sets which Providers are responsible.</li> <li>Provider: Generates events and sends them to Sessions.</li> <li>Consumer: Views and utilizes data from Sessions.</li> <li>Session: Records events from one or more Providers and manages/clears buffer data.</li> </ul>"},{"location":"Learn/EDR/ETW/#windows10etwevents","title":"Windows10EtwEvents","text":"<p>One Provider may offer multiple events, each identified by a specific Event ID.</p> <p>Therefore, there are online resources that compile information about various Providers and their corresponding event IDs. For details, please refer to Windows10EtwEvents.</p> <p>Example : </p> <p>Check Microsoft-Windows-Kernel-Process event</p> <p></p>"},{"location":"Learn/EDR/ETW/#using-etw","title":"Using ETW:","text":"<p>Windows includes a built-in tool called Logman, which can be used to view information about Providers and the status of Sessions.</p> <p>Example :</p> <ul> <li><code>logman query providers</code> allows you to see all configured Providers on the system</li> </ul> <p></p> <ul> <li> <p>Viewing a specific Provider</p> <p></p> </li> <li> <p><code>logman create trace powershell-tracing -ets</code> Creating a session</p> <p></p> </li> <li> <p><code>logman update powershell-tracing -p Microsoft-Windows-PowerShell 0x83 -ets</code></p> <p>This command allows you to specify a Provider and choose the events provided by the Provider.</p> <ul> <li><code>-p</code>  choose Provider</li> <li><code>0x83</code> subscribes to events from <code>Microsoft-Windows-PowerShell</code><ul> <li>0x0000000000000001  Runspace</li> <li>0x0000000000000002  Pipeline</li> <li>0x0000000000000080  Session</li> <li> <p>0x01 + 0x02 + 0x80 = 0x83</p> <p></p> </li> </ul> </li> </ul> </li> <li> <p>You can see <code>powershell-tracing.etl</code> from the Event Viewer.</p> <p></p> </li> </ul>"},{"location":"Learn/EDR/ETW/#krabsetw","title":"krabsetw","text":"<p>krabsetw is a C++ library that simplifies interaction with ETW. For details, please refer to krabsetw\u3002</p> <p>The following uses the krabsetw library to monitor process start events in the Windows system.</p> <pre><code>#include &lt;krabs.hpp&gt;\n#include &lt;iostream&gt;\n\nvoid start_etw_trace()\n{\n    krabs::user_trace trace;\n\n    krabs::provider&lt;&gt; provider(L\"Microsoft-Windows-Kernel-Process\"); //choose Provider\n    provider.any(0x10);  // choose event WINEVENT_KEYWORD_PROCESS\n\n    auto process_callback = [](const EVENT_RECORD&amp; record, const krabs::trace_context&amp; trace_context) {\n        krabs::schema schema(record, trace_context.schema_locator); // Definition of file structure\n        krabs::parser parser(schema); // Used for parsing and extracting specific property values from event logs.\n        uint32_t ppid = parser.parse&lt;uint32_t&gt;(L\"ParentProcessID\");\n        uint32_t pid = parser.parse&lt;uint32_t&gt;(L\"ProcessID\");\n        std::wstring image_name = parser.parse&lt;std::wstring&gt;(L\"ImageName\");\n\n        std::wcout &lt;&lt; L\"[&gt;] Process Name: \" &lt;&lt; image_name &lt;&lt; std::endl;\n        std::wcout &lt;&lt; L\"[&gt;] ParentProcess ID: \" &lt;&lt; ppid &lt;&lt; std::endl;\n        std::wcout &lt;&lt; L\"[&gt;] ProcessID \" &lt;&lt; pid &lt;&lt; std::endl;\n        std::wcout &lt;&lt; std::endl;\n        };\n\n    // real-time process start events\n    krabs::event_filter process_filter(krabs::predicates::id_is(1)); // Only capture events with ID 1.\n    process_filter.add_on_event_callback(process_callback); // When the filter captures an event, it will be passed to a callback for processing.\n    provider.add_filter(process_filter); // Add the filter to the provider.\n\n    trace.enable(provider); // Set up to use the specified Provider.\n    trace.start(); // Event tracing will officially start.\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"[+] Monitoring Starting!\\n\" &lt;&lt; std::endl;\n    start_etw_trace();\n}\n</code></pre>  \ud83d\udc47 Note : The executable needs to be run with administrator privileges to function properly.   <p></p>"},{"location":"Learn/EDR/ETW/#etwprocessmon2","title":"ETWProcessMon2","text":"<p>ETWProcessMon2 is for Monitoring Process/Thread/Memory/Imageloads/TCPIP via ETW + Detection for Remote-Thread-Injection &amp; Payload Detection by VirtualMemAlloc Events (in-memory) etc. For details, please refer to ETWProcessMon2 \u3002</p>"},{"location":"Learn/EDR/ETW/#tools","title":"Tools","text":"<ul> <li>https://github.com/jdu2600/Windows10EtwEvents</li> <li>https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/logman</li> <li>https://github.com/DamonMohammadbagher/ETWProcessMon2?tab=readme-ov-file</li> </ul>"},{"location":"Learn/EDR/ETW/#resource","title":"Resource","text":"<ul> <li>https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/etw-event-tracing-for-windows-101</li> <li>https://github.com/microsoft/krabsetw</li> <li>https://blog.securehat.co.uk/detection-experiments/detecting-parent-process-spoofing-using-krabsetw</li> </ul>"},{"location":"Learn/EDR/Yara/","title":"Yara","text":""},{"location":"Learn/Malware/Bypass-API-Hooking/","title":"Bypass API Hooking","text":"<p>API hooking modifies the content of Windows APIs in system libraries (e.g., <code>ntdll.dll</code>, <code>kernel32.dll</code>, ...) in memory to place hooks and hijack the control flow. There are basically two methods to bypass API hooking. One method is to restore the original system library in memory, and the other method is to bypass Windows APIs altogether and call syscall directly.</p> <p>To restore system library, such as <code>ntdll.dll</code>, in memory comes several ways:</p> <ul> <li>Read <code>ntdll.dll</code> from filesystem and overwrite <code>ntdll.dll</code> in memory</li> <li>Map <code>\\KnownDlls\\ntdll.dll</code> section to memory</li> </ul> <p>However, there are some disadvantages to restoring system libraries. First, you still need to call Windows APIs to read the file, which are monitored by EDR. Second, EDR can reapply API hooking.</p> <p>The second method is to call syscalls directly, avoiding Windows APIs altogether. Unlike Linux, Windows changes the mapping of SSNs (System Service Numbers) frequently. To call syscalls in Windows, you need to know the SSN mapping for different Windows versions. There are various ways to obtain this mapping:</p> <ul> <li>SSN mapping maintained by SysWhisper</li> <li>Parsing <code>Nt-</code> / <code>Zw-</code> APIs from <code>ntdll.dll</code> in memory and sorting them by address, which is a preferred method nowadays. This approach allows us to avoid maintaining the SSN mapping ourselves, as we can derive it from <code>ntdll.dll</code>. SysWhispers3 implement this kind of method.</li> </ul> <p>EDR can easily detect syscall behavior by statically scanning for syscall patterns, as normal programs do not use syscalls directly. To avoid detection, malware can generate the syscall assembly at runtime, a technique implemented as <code>egghunter</code> in SysWhispers3.</p> <p>Additionally, EDR can detect syscall behavior by examining the program's call stack. Typically, a program will enter the kernel directly instead of going through <code>ntdll.dll</code>. To evade this, malware can use a syscall gadget and jump to ntdll.dll after setting the SSN in the rax register. This technique is implemented as <code>jumper</code> in SysWhispers3.</p>"},{"location":"Learn/Malware/Bypass-API-Hooking/#tools","title":"Tools","text":"<ul> <li>https://github.com/jthuraisamy/SysWhispers</li> <li>https://github.com/jthuraisamy/SysWhispers2</li> <li>https://github.com/klezVirus/SysWhispers3</li> <li>https://github.com/crummie5/FreshyCalls</li> </ul>"},{"location":"Learn/Malware/Bypass-API-Hooking/#resource","title":"Resource","text":"<ul> <li>https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/</li> <li>https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/</li> <li>https://www.crow.rip/crows-nest/mal/dev/inject/syscalls/indirect-syscalls</li> <li>https://dosxuz.gitlab.io/post/perunsfart/</li> <li>https://blog.sektor7.net/#!res/2021/perunsfart.md</li> </ul>"},{"location":"Learn/Malware/ETW-Patch/","title":"ETW Patch","text":""},{"location":"Learn/Malware/Obfuscation/","title":"Obfuscation","text":""},{"location":"Learn/Malware/PPID-Spoofing/","title":"PPID Spoofing","text":""},{"location":"Learn/Malware/Packing/","title":"Packing","text":""},{"location":"Learn/Malware/Packing/#what-is-packer","title":"What is packer?","text":"<p><sup>1</sup></p> <p>A packer is a tool that combines an executable file's code, data, and sometimes resources into a single package. It includes code to unpack the program dynamically and execute it, without altering the program's original purpose. </p>"},{"location":"Learn/Malware/Packing/#what-types-of-packers-are-there","title":"What types of packers are there?","text":"<p>It is generally one or a combination of the following operations:<sup>2</sup></p>"},{"location":"Learn/Malware/Packing/#bundling","title":"bundling","text":"<p>Makes a single executable with multiple files.</p> <ul> <li>PyInstaller</li> <li>cx_Freeze</li> <li>py2exe</li> <li>PyOxidizer</li> <li>Nuitka</li> <li>Briefcase</li> </ul>"},{"location":"Learn/Malware/Packing/#compression","title":"compression","text":"<p>Compresses the executable to reduce its original size.</p> <ul> <li>UPX</li> <li>PEtite</li> <li>MPRESS</li> <li>PECompact</li> <li>kkrunchy</li> <li>ASPack</li> </ul>"},{"location":"Learn/Malware/Packing/#obfuscates","title":"obfuscates","text":"<p>Obfuscates the executable by encodin/gencrypting it.</p> <ul> <li>ExeCryptor</li> <li>ELFCrypt</li> <li>Code Virtualizer</li> <li>Dotfuscator</li> <li>ConfuserEx</li> <li>xorPacker</li> <li>Hyperion</li> </ul>"},{"location":"Learn/Malware/Packing/#protection","title":"protection","text":"<p>Makes the reversing of the executable harder (i.e. using anti-debugging, anti-tampering or other tricks).</p> <ul> <li>ExeCryptor</li> <li>Themida</li> <li>ASProtect</li> <li>Enigma Protector</li> <li>VMProtect</li> <li>ZProtect</li> </ul>"},{"location":"Learn/Malware/Packing/#virtualization","title":"virtualization","text":"<p>Embeds a virtual machine that virtualizes the instructions of executable files.  It uses a customized and different virtual instruction set every time to protect your application.  The virtual machine can be a simple interpreter or a complex virtualization engine, responsible for decrypting and executing the wrapped code at runtime.  Virtualization technology creates an abstraction layer, hiding the actual instructions and data of the malicious software within the virtual machine, making reverse engineering and detection more challenging.</p> <ul> <li>Themida</li> <li>ASProtect</li> <li>Enigma Protector</li> <li>VMProtect</li> <li>Molebox</li> </ul>"},{"location":"Learn/Malware/Packing/#what-its-used-for","title":"What It's Used For?","text":"<p>Malware authors hide their malicious code behind this compression layer. This code is only decompressed and executed after the malware runs (in runtime mode), which helps malware authors bypass static signature-based detection.</p> <ol> <li>Increased Difficulty for Static Analysis.<ul> <li>Obfuscation: Techniques used to obscure the code's logic and structure, making it harder for analysts to understand.</li> <li>Multi-Layer Packing: Employing multiple layers of packing to further complicate analysis and increase resistance to detection.</li> </ul> </li> <li>Bypassing Signature Detection.<ul> <li>Changing File Signatures: Modifying the executable's file signature to evade detection by security software that relies on file signatures for identification.</li> </ul> </li> </ol> <p>By employing these tactics, malicious software authors aim to evade detection by security measures that rely on straightforward identification or behavioral analysis. This layered approach complicates the process for security analysts and software defenses, allowing the malware to operate undetected for longer periods and potentially causing harm to systems and data.</p> <ol> <li> <p>The process of unpacking a sample \u21a9</p> </li> <li> <p>awesome-executable-packing \u21a9</p> </li> </ol>"},{"location":"Learn/Malware/Process-Injection/","title":"Process Injection","text":""}]}