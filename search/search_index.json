{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BOMBE Docs","text":"<p>Welcome to BOMBE Docs!</p> <p>BOMBE (Battle Of Malware Bypass and EDR) is a match where malware and EDR systems compete against each other inside a single VM. It's like a Attack and Defense style of CTF, but different! We will provide quick start guide and some direction for those who are new to this field.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"Learn/EDR/API-Hooking/","title":"API Hooking","text":""},{"location":"Learn/EDR/ETW/","title":"ETW","text":"<p>Event Tracing for Windows (ETW) provides a mechanism to trace and log events that are raised by user-mode applications and kernel-mode drivers.</p> <p></p> <p>The components of ETW include Controller, Provider, Consumer, and Session :</p> <ul> <li>Controller: Controls the enabling/disabling of Providers, creates Sessions, and sets which Providers are responsible.</li> <li>Provider: Generates events and sends them to Sessions.</li> <li>Consumer: Views and utilizes data from Sessions.</li> <li>Session: Records events from one or more Providers and manages/clears buffer data.</li> </ul>"},{"location":"Learn/EDR/ETW/#windows10etwevents","title":"Windows10EtwEvents","text":"<p>One Provider may offer multiple events, each identified by a specific Event ID.</p> <p>Therefore, there are online resources that compile information about various Providers and their corresponding event IDs. For details, please refer to Windows10EtwEvents.</p> <p>Example : </p> <p>Check Microsoft-Windows-Kernel-Process event</p> <p></p>"},{"location":"Learn/EDR/ETW/#using-etw","title":"Using ETW:","text":"<p>Windows includes a built-in tool called Logman, which can be used to view information about Providers and the status of Sessions.</p> <p>Example :</p> <ul> <li><code>logman query providers</code> allows you to see all configured Providers on the system</li> </ul> <p></p> <ul> <li> <p>Viewing a specific Provider</p> <p></p> </li> <li> <p><code>logman create trace powershell-tracing -ets</code> Creating a session</p> <p></p> </li> <li> <p><code>logman update powershell-tracing -p Microsoft-Windows-PowerShell 0x83 -ets</code></p> <p>This command allows you to specify a Provider and choose the events provided by the Provider.</p> <ul> <li><code>-p</code>  choose Provider</li> <li><code>0x83</code> subscribes to events from <code>Microsoft-Windows-PowerShell</code><ul> <li>0x0000000000000001  Runspace</li> <li>0x0000000000000002  Pipeline</li> <li>0x0000000000000080  Session</li> <li> <p>0x01 + 0x02 + 0x80 = 0x83</p> <p></p> </li> </ul> </li> </ul> </li> <li> <p>You can see <code>powershell-tracing.etl</code> from the Event Viewer.</p> <p></p> </li> </ul>"},{"location":"Learn/EDR/ETW/#krabsetw","title":"krabsetw","text":"<p>krabsetw is a C++ library that simplifies interaction with ETW. For details, please refer to krabsetw\u3002</p> <p>The following uses the krabsetw library to monitor process start events in the Windows system.</p> <pre><code>#include &lt;krabs.hpp&gt;\n#include &lt;iostream&gt;\n\nvoid start_etw_trace()\n{\n    krabs::user_trace trace;\n\n    krabs::provider&lt;&gt; provider(L\"Microsoft-Windows-Kernel-Process\"); //choose Provider\n    provider.any(0x10);  // choose event WINEVENT_KEYWORD_PROCESS\n\n    auto process_callback = [](const EVENT_RECORD&amp; record, const krabs::trace_context&amp; trace_context) {\n        krabs::schema schema(record, trace_context.schema_locator); // Definition of file structure\n        krabs::parser parser(schema); // Used for parsing and extracting specific property values from event logs.\n        uint32_t ppid = parser.parse&lt;uint32_t&gt;(L\"ParentProcessID\");\n        uint32_t pid = parser.parse&lt;uint32_t&gt;(L\"ProcessID\");\n        std::wstring image_name = parser.parse&lt;std::wstring&gt;(L\"ImageName\");\n\n        std::wcout &lt;&lt; L\"[&gt;] Process Name: \" &lt;&lt; image_name &lt;&lt; std::endl;\n        std::wcout &lt;&lt; L\"[&gt;] ParentProcess ID: \" &lt;&lt; ppid &lt;&lt; std::endl;\n        std::wcout &lt;&lt; L\"[&gt;] ProcessID \" &lt;&lt; pid &lt;&lt; std::endl;\n        std::wcout &lt;&lt; std::endl;\n        };\n\n    // real-time process start events\n    krabs::event_filter process_filter(krabs::predicates::id_is(1)); // Only capture events with ID 1.\n    process_filter.add_on_event_callback(process_callback); // When the filter captures an event, it will be passed to a callback for processing.\n    provider.add_filter(process_filter); // Add the filter to the provider.\n\n    trace.enable(provider); // Set up to use the specified Provider.\n    trace.start(); // Event tracing will officially start.\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"[+] Monitoring Starting!\\n\" &lt;&lt; std::endl;\n    start_etw_trace();\n}\n</code></pre>  \ud83d\udc47 Note : The executable needs to be run with administrator privileges to function properly.   <p></p>"},{"location":"Learn/EDR/ETW/#etwprocessmon2","title":"ETWProcessMon2","text":"<p>ETWProcessMon2 is for Monitoring Process/Thread/Memory/Imageloads/TCPIP via ETW + Detection for Remote-Thread-Injection &amp; Payload Detection by VirtualMemAlloc Events (in-memory) etc. For details, please refer to ETWProcessMon2 \u3002</p>"},{"location":"Learn/EDR/ETW/#tools","title":"Tools","text":"<ul> <li>https://github.com/jdu2600/Windows10EtwEvents</li> <li>https://learn.microsoft.com/zh-tw/windows-server/administration/windows-commands/logman</li> <li>https://github.com/DamonMohammadbagher/ETWProcessMon2?tab=readme-ov-file</li> </ul>"},{"location":"Learn/EDR/ETW/#resource","title":"Resource","text":"<ul> <li>https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/etw-event-tracing-for-windows-101</li> <li>https://github.com/microsoft/krabsetw</li> <li>https://blog.securehat.co.uk/detection-experiments/detecting-parent-process-spoofing-using-krabsetw</li> </ul>"},{"location":"Learn/EDR/Yara/","title":"Yara rule","text":"<p>YARA is a tool primarily used for identifying and classifying malware samples. It is widely utilized in cybersecurity, especially by threat hunters and researchers.</p> <p>What we can do with Yara?</p> <ul> <li>Identify and classify malware</li> <li>find new malware samples and based on family-specific features</li> <li>find new exploits and zero-days</li> <li>help speeding up incident response</li> <li>classification: identify file formats, archives, packed files, known threats</li> <li>build your own private antivirus</li> </ul>"},{"location":"Learn/EDR/Yara/#recommended-software-when-writing-yara-rule","title":"Recommended software when writing Yara rule","text":"<p>These tools can help you write YARA rules more smoothly.</p> <ul> <li>String analyzer</li> <li>PE file structure viewer</li> <li>Hex viewer</li> <li>Binary diffing tool</li> <li>IDA Pro / Ghidra</li> </ul>"},{"location":"Learn/EDR/Yara/#the-components-of-yara","title":"The components of Yara","text":"<p>Yara include Meta, Strings, Condition</p> <ul> <li>Meta: The meta section contains metadata about the rule. It's not used for matching but provides useful information.</li> <li>String: The strings section lists the patterns the rule is looking for in the files.</li> <li>Condition: The condition section defines the criteria for the rule to match.</li> </ul>"},{"location":"Learn/EDR/Yara/#example-of-yara-rule","title":"Example of Yara rule","text":"<pre><code>rule ExampleRule {\n    meta:\n        author = \"Bobo\"\n        type = \"APT\"\n        description = \"This rule detects a specific malicious file based on known strings.\"\n        date = \"2024-07-01\"\n    strings:\n        $string1 = \"malicious_string_1\"\n        $string2 = \"malicious_string_2\"\n        $hex_string = { 6D 61 6C 69 63 69 6F 75 73 }\n    condition:\n        (uint16(0) == 0x4D5A) and (any of ($string*)) (filesize &lt; 5000000) and ($hex_string)\n}\n</code></pre> <p>In the above example : </p> <ul> <li>The meta section includes information about this rule such as the author's name, category, a brief description, and the creation date</li> <li>The strings section includes what the rule looking for :<ul> <li>$string1: This string identifier looks for the ASCII string \"malicious_string_1\". </li> <li>$string2: This string identifier looks for the ASCII string \"malicious_string_2\". </li> <li>$hex_string: This identifier looks for a specific sequence of hexadecimal bytes (which translates to the ASCII string \"malicious\").</li> </ul> </li> <li>In this condition, it means that it should successfully match certain conditions.<ul> <li>uint16(0) == 0x4D5A: This checks if the first two bytes of the file are 0x4D5A, which is the magic number for a Windows executable (MZ header).</li> <li>any of ($string*): This checks if any of the strings defined in the strings section (with identifiers starting with $string) are present in the file.</li> <li>the filesize can't &gt; 5MB</li> <li>($hex_string): This checks if the specific hexadecimal string is present in the file.</li> </ul> </li> </ul> <p>To run this rule, open the terminal and type : </p> <pre><code>yara -r -s ExampleRule.yara  game.exe\n</code></pre> <p><code>-r</code> is used to check all the directory recursively. <code>-s</code> is used to show the matched strings. ExampleRule.yara is the rule file we made earlier. game.exe is the malware file we check for matching strings.</p> <p>For more detailed information about YARA rule keywords and methods, please refer to its documentation. https://yara.readthedocs.io/en/stable/index.html</p>"},{"location":"Learn/EDR/Yara/#using-yara-from-python","title":"Using Yara from Python","text":"<p>Here's a simple example of writing a YARA scanner in Python using the yara-python library. This script will compile a YARA rule, scan a file for matches, and print the results.</p> <p>Before you start, make sure you have the yara-python library installed. You can install it using pip:</p> <pre><code>pip install yara-python\n</code></pre> <p>The Yara rule using what we have just created:</p> <pre><code>rule ExampleRule {\n    meta:\n        author = \"Bobo\"\n        type = \"APT\"\n        description = \"This rule detects a specific malicious file based on known strings.\"\n        date = \"2024-07-01\"\n    strings:\n        $string1 = \"malicious_string_1\"\n        $string2 = \"malicious_string_2\"\n        $hex_string = { 6D 61 6C 69 63 69 6F 75 73 }\n    condition:\n        (uint16(0) == 0x4D5A) and (any of ($string*)) (filesize &lt; 5000000) and ($hex_string)\n}\n</code></pre> <p>Next, create a Python script named yara_scanner.py:</p> <pre><code>import yara\n\n# Define the path to the YARA rule file and the file to scan\nrule_file = 'example_rule.yar'\nfile_to_scan = 'sample_file.exe'\n\n# Compile the YARA rule\nrules = yara.compile(filepath=rule_file)\n\n# Scan the file\nmatches = rules.match(file_to_scan)\n\n# Print the results\nif matches:\n    print(f\"YARA rule matched! Details:\\n{matches}\")\nelse:\n    print(\"No matches found.\")\n</code></pre> <p>To run the script, save it as yara_scanner.py and run it in your terminal:</p> <pre><code>python yara_scanner.py\n</code></pre> <p>Make sure you have a file named sample_file.exe to scan in the same directory as the script or provide the correct path to a file you want to scan.</p> <p>For more detailed information about Yara-python  keywords and methods, please refer to its documentation https://yara.readthedocs.io/en/stable/yarapython.html</p>"},{"location":"Learn/EDR/Yara/#tools","title":"Tools","text":"<ul> <li>https://github.com/VirusTotal/yara</li> <li>https://github.com/VirusTotal/yara-python</li> <li>https://github.com/InQuest/awesome-yara</li> <li>https://github.com/100DaysofYARA</li> </ul>"},{"location":"Learn/EDR/Yara/#resource","title":"Resource","text":"<ul> <li>https://www.brighttalk.com/webcast/15591/388802</li> <li>https://www.picussecurity.com/resource/glossary/what-is-a-yara-rule</li> <li>https://www.varonis.com/blog/yara-rules</li> </ul>"},{"location":"Learn/Malware/Bypass-API-Hooking/","title":"Bypass API Hooking","text":"<p>API hooking modifies the content of Windows APIs in system libraries (e.g., <code>ntdll.dll</code>, <code>kernel32.dll</code>, ...) in memory to place hooks and hijack the control flow. There are basically two methods to bypass API hooking. One method is to restore the original system library in memory, and the other method is to bypass Windows APIs altogether and call syscall directly.</p> <p>To restore system library, such as <code>ntdll.dll</code>, in memory comes several ways:</p> <ul> <li>Read <code>ntdll.dll</code> from filesystem and overwrite <code>ntdll.dll</code> in memory</li> <li>Map <code>\\KnownDlls\\ntdll.dll</code> section to memory</li> </ul> <p>However, there are some disadvantages to restoring system libraries. First, you still need to call Windows APIs to read the file, which are monitored by EDR. Second, EDR can reapply API hooking.</p> <p>The second method is to call syscalls directly, avoiding Windows APIs altogether. Unlike Linux, Windows changes the mapping of SSNs (System Service Numbers) frequently. To call syscalls in Windows, you need to know the SSN mapping for different Windows versions. There are various ways to obtain this mapping:</p> <ul> <li>SSN mapping maintained by SysWhisper</li> <li>Parsing <code>Nt-</code> / <code>Zw-</code> APIs from <code>ntdll.dll</code> in memory and sorting them by address, which is a preferred method nowadays. This approach allows us to avoid maintaining the SSN mapping ourselves, as we can derive it from <code>ntdll.dll</code>. SysWhispers3 implement this kind of method.</li> </ul> <p>EDR can easily detect syscall behavior by statically scanning for syscall patterns, as normal programs do not use syscalls directly. To avoid detection, malware can generate the syscall assembly at runtime, a technique implemented as <code>egghunter</code> in SysWhispers3.</p> <p>Additionally, EDR can detect syscall behavior by examining the program's call stack. Typically, a program will enter the kernel directly instead of going through <code>ntdll.dll</code>. To evade this, malware can use a syscall gadget and jump to ntdll.dll after setting the SSN in the rax register. This technique is implemented as <code>jumper</code> in SysWhispers3.</p>"},{"location":"Learn/Malware/Bypass-API-Hooking/#tools","title":"Tools","text":"<ul> <li>https://github.com/jthuraisamy/SysWhispers</li> <li>https://github.com/jthuraisamy/SysWhispers2</li> <li>https://github.com/klezVirus/SysWhispers3</li> <li>https://github.com/crummie5/FreshyCalls</li> </ul>"},{"location":"Learn/Malware/Bypass-API-Hooking/#resource","title":"Resource","text":"<ul> <li>https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/</li> <li>https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/</li> <li>https://www.crow.rip/crows-nest/mal/dev/inject/syscalls/indirect-syscalls</li> <li>https://dosxuz.gitlab.io/post/perunsfart/</li> <li>https://blog.sektor7.net/#!res/2021/perunsfart.md</li> </ul>"},{"location":"Learn/Malware/ETW-Patch/","title":"ETW Patch","text":""},{"location":"Learn/Malware/Obfuscation/","title":"Obfuscation","text":""},{"location":"Learn/Malware/PPID-Spoofing/","title":"PPID Spoofing","text":""},{"location":"Learn/Malware/Packing/","title":"Packing","text":""},{"location":"Learn/Malware/Packing/#what-is-packer","title":"What is packer?","text":"<p><sup>1</sup></p> <p>A packer is a tool that combines an executable file's code, data, and sometimes resources into a single package. It includes code to unpack the program dynamically and execute it, without altering the program's original purpose. </p>"},{"location":"Learn/Malware/Packing/#what-types-of-packers-are-there","title":"What types of packers are there?","text":"<p>It is generally one or a combination of the following operations:<sup>2</sup></p>"},{"location":"Learn/Malware/Packing/#bundling","title":"bundling","text":"<p>Makes a single executable with multiple files.</p> <ul> <li>PyInstaller</li> <li>cx_Freeze</li> <li>py2exe</li> <li>PyOxidizer</li> <li>Nuitka</li> <li>Briefcase</li> </ul>"},{"location":"Learn/Malware/Packing/#compression","title":"compression","text":"<p>Compresses the executable to reduce its original size.</p> <ul> <li>UPX</li> <li>PEtite</li> <li>MPRESS</li> <li>PECompact</li> <li>kkrunchy</li> <li>ASPack</li> </ul>"},{"location":"Learn/Malware/Packing/#obfuscates","title":"obfuscates","text":"<p>Obfuscates the executable by encodin/gencrypting it.</p> <ul> <li>ExeCryptor</li> <li>ELFCrypt</li> <li>Code Virtualizer</li> <li>Dotfuscator</li> <li>ConfuserEx</li> <li>xorPacker</li> <li>Hyperion</li> </ul>"},{"location":"Learn/Malware/Packing/#protection","title":"protection","text":"<p>Makes the reversing of the executable harder (i.e. using anti-debugging, anti-tampering or other tricks).</p> <ul> <li>ExeCryptor</li> <li>Themida</li> <li>ASProtect</li> <li>Enigma Protector</li> <li>VMProtect</li> <li>ZProtect</li> </ul>"},{"location":"Learn/Malware/Packing/#virtualization","title":"virtualization","text":"<p>Embeds a virtual machine that virtualizes the instructions of executable files.  It uses a customized and different virtual instruction set every time to protect your application.  The virtual machine can be a simple interpreter or a complex virtualization engine, responsible for decrypting and executing the wrapped code at runtime.  Virtualization technology creates an abstraction layer, hiding the actual instructions and data of the malicious software within the virtual machine, making reverse engineering and detection more challenging.</p> <ul> <li>Themida</li> <li>ASProtect</li> <li>Enigma Protector</li> <li>VMProtect</li> <li>Molebox</li> </ul>"},{"location":"Learn/Malware/Packing/#what-its-used-for","title":"What It's Used For?","text":"<p>Malware authors hide their malicious code behind this compression layer. This code is only decompressed and executed after the malware runs (in runtime mode), which helps malware authors bypass static signature-based detection.</p> <ol> <li>Increased Difficulty for Static Analysis.<ul> <li>Obfuscation: Techniques used to obscure the code's logic and structure, making it harder for analysts to understand.</li> <li>Multi-Layer Packing: Employing multiple layers of packing to further complicate analysis and increase resistance to detection.</li> </ul> </li> <li>Bypassing Signature Detection.<ul> <li>Changing File Signatures: Modifying the executable's file signature to evade detection by security software that relies on file signatures for identification.</li> </ul> </li> </ol> <p>By employing these tactics, malicious software authors aim to evade detection by security measures that rely on straightforward identification or behavioral analysis. This layered approach complicates the process for security analysts and software defenses, allowing the malware to operate undetected for longer periods and potentially causing harm to systems and data.</p> <ol> <li> <p>The process of unpacking a sample \u21a9</p> </li> <li> <p>awesome-executable-packing \u21a9</p> </li> </ol>"},{"location":"Learn/Malware/Process-Injection/","title":"Process Injection","text":""}]}