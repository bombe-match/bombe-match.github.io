# ETW Patch

ETW defense uses LDAP, .NET, AMSI, etc.

Currently, patching functions in the local process is much easier than patching remote processes because it requires the use of functions like `WriteProcessMemory`.

### **LDAP**
LDAP (Lightweight Directory Access Protocol)

Like an address book, it records personnel information and can be used for account integration and authentication. LDAP directory services typically have a hierarchical structure, similar to a company’s organizational hierarchy.

---

### LDAP Usage :

A common use of LDAP is single sign-on (SSO).

Users can use the same password across multiple services, typically for logging into corporate intranet websites.

This way, they can log in once on their company computer and automatically gain access to the corporate intranet.

Before performing LDAP activities, you need to locate the memory addresses of the functions you want to modify.

These functions might be `EtwEventWrite`, `LDAPSearchLoggingClientTraceEventNoReg`, or `NtTraceEvent`.

These functions are related to writing and logging ETW events.

After locating the memory addresses of these functions, you can provide alternative instructions to patch them.

The purpose of doing this is to prevent these functions from performing their default logging operations.

### **AMSI**

**Anti-Malware Scan Interface - Windows Antimalware (AMSI)**

AMSI is a versatile interface standard that allows your applications and services to integrate with any anti-malware product on the computer.

AMSI provides enhanced malware protection for your end users, their data, applications, and workloads.

AMSI is vendor-agnostic; it is designed to allow the most common malware scanning and protection technologies provided by today's anti-malware products to integrate into applications. It supports call structures that enable file and memory or stream scanning, content source URL/IP reputation checks, and other techniques.

AMSI also supports the concept of sessions, allowing anti-malware vendors to correlate different scan requests. For example, different fragments of a malicious payload can be associated to make more informed decisions, which would be more difficult if these fragments were viewed in isolation.

### Windows Components Integrated with AMSI :

AMSI functionality has been integrated into these components of Windows 10:

- User Account Control (UAC) (EXE, COM, MSI, or ActiveX installation elevation)
- PowerShell (scripts, interactive use, and dynamic code evaluation)
- Windows Script Host (wscript.exe and cscript.exe)
- JavaScript and VBScript
- Office VBA macros

Below is a diagram of the AMSI architecture, where your own application is represented by one of the [other applications] boxes.

![amsi.png](../../assets/ETWpic/logman1.png)

The Windows AMSI interface is open. This means any application can call it, and any registered anti-malware engine can process the content submitted to it.

We do not need to limit the discussion to script engines. Perhaps your application is a communication app that scans instant messages for viruses before displaying them to your users. Or your software might verify game plugins before installing them. There are many opportunities and use cases for using AMSI.

### **wldap32.dll **

The LDAP client library in Windows includes functions related to the LDAP protocol.

When performing LDAP activities, wldap32.dll is loaded into the process.

### **Types of Patching**

### **GetProcAddress

`GetProcAddress` is a Win32 API function.

It is used to obtain the address of an exported function or variable from a DLL (Dynamic Link Library).

1. **Load the DLL** :
    - Before calling `GetProcAddress`, you need to obtain the module handle of the function, usually done via the `LoadLibrary` function.
    - `LoadLibrary` loads the specified DLL into the address space of the calling process and returns a module handle.
    
    ```c
    HMODULE hModule = LoadLibrary("example.dll");
    ```
2. **Get the function address** :
    - Once you have the module handle, you can use `GetProcAddress` to obtain the address of the desired function.
    
    ```c
    FARPROC pFunc = GetProcAddress(hModule, "FunctionName");
    ```
3. **Change memory protection**:
    - The memory area where the function resides may need to have its protection settings changed to allow writing because code sections are typically read-only and executable.
    - This can be accomplished using the `VirtualProtect` function, which changes the protection of pages in the virtual address space of the calling process.
    
    ```c
    DWORD oldProtect;
    VirtualProtect(pFunc, size, PAGE_EXECUTE_READWRITE, &oldProtect);
    ```
4. **Patch the function**:
    - Once memory protection is changed, you can modify the function's instructions.
    - This can be done in various ways, such as overwriting the first few bytes of the function to insert a jump to custom code or simply replacing instructions with a return statement to bypass the function.
    
    ```c
    // Example: patch the function to immediately return
    unsigned char patch[] = { 0xC3 }; // x86 'ret' instruction
    memcpy(pFunc, patch, sizeof(patch));
    ```
5. **Restore memory protection**:
    - After patching, it is advisable to restore the original memory protection settings to avoid potential security issues.
    
    ```c
    VirtualProtect(pFunc, size, oldProtect, &oldProtect);
    ```
**Limitations :**
- **Export Table Requirement**: A major limitation of `GetProcAddress` is that it only applies to functions exported by the DLL. The function must be listed in the DLL's export table.

- **Internal Functions**: If the function you want to patch is not exported (i.e., it is an internal function), `GetProcAddress` cannot obtain its address. In such cases, you may need to use binary analysis, reverse engineering, or a debugger to locate and patch internal functions.

**Example Use Case :**
Suppose you have a DLL, `example.dll`, which exports a function `ExampleFunction`, and you want to patch this function so that it always returns immediately:

1. **Load the DLL**:
    
    ```c
    HMODULE hModule = LoadLibrary("example.dll");
    ```
    
2. **Get the function address**:
    
    ```c
    FARPROC pFunc = GetProcAddress(hModule, "ExampleFunction");
    ```
    
3. **Change memory protection**:
    
    ```c
    DWORD oldProtect;
    VirtualProtect(pFunc, sizeof(patch), PAGE_EXECUTE_READWRITE, &oldProtect);
    
    ```
    
4. **Patch the function**:
    
    ```c
    unsigned char patch[] = { 0xC3 }; // x86 'ret' instruction
    memcpy(pFunc, patch, sizeof(patch));
    ```
    
5. **Restore memory protection**:
    
    ```c
    VirtualProtect(pFunc, sizeof(patch), oldProtect, &oldProtect);
    ```


### **Manual Function Pointer
When you find a function and want to patch it, you only need to determine the function's virtual address offset within the DLL.

Once you have this offset and the DLL is loaded into a process, you can obtain the base address of the DLL in memory and add the virtual address offset to this base address to get a pointer to the function.
```c
//
 // Go to offset: 0x1708c - LDAPSearchLoggingClientTraceEventNoReg
 //
 DWORD offset = 0x1708c;
 // Calculate the absolute address by adding the offset to the base address of the module
LPVOID ldapClient = reinterpret_cast<LPVOID>(reinterpret_cast<DWORD_PTR>(hModule) + offset);
std::cout << "[+] Address of LDAPSearchLoggingClientTraceEventNoReg: " << ldapClient << std::endl;
```
Subsequently, follow the same process to change the memory protection settings and manipulate the code flow.

This method applies to both internal and external functions.

Different versions of the DLL may change the virtual address offset.

This looks roughly like this:


### **Kernel
**Example 1: Beacon LogonPasswords:**
In the example, there is a process named `beacon.exe`.

`beacon.exe` invokes mimikatz’s logonprocess function to dump LSASS.

This does not patch ETW, and we can see ReadProcessMemory events obtained from the ETW Threat Intelligence provider.

The process shown in the image is `dllhost.exe`, but this is a CobaltStrike-ism that executes commands through process injection. It is derived from `beacon.exe`.

![beacon1.png](../../assets/ETWpic/logman2.png)

**Example 2: inlineExecute-Assembly + SharpDump:**
This example uses `inlineExecute-Assembly` to call SharpDump to dump LSASS.

It uses the “—etw” flag to patch EtwEventWrite.

This should display events from the DotNet ETW provider, but due to the presence of the “—etw” flag, no events are shown.

![example2.png](../../assets/ETWpic/logman2.png)

The second image shows that, despite patching ETW through EtwEventWrite, the Threat-Intelligence provider still writes a ReadProcessMemory event because the Threat-Intelligence provider is located in the kernel rather than user-mode.
![example3.png](../../assets/ETWpic/logman2.png)

### **Resource**

- [https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
- [https://jsecurity101.medium.com/understanding-etw-patching-9f5af87f9d7b](https://jsecurity101.medium.com/understanding-etw-patching-9f5af87f9d7b)
- [https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch](https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch)
